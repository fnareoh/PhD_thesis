\section{Preliminaries}\label{sec:prelim}

\todo[inline]{Once the preliminaries have been completed, possibly add the relevant reference in the introduction}

This section aims at presenting the basic concepts that are needed to understand the following chapters, as well as presenting the different form of compression used in this work and their connections.

A string of length $n$ is a sequence $T[0] \dots T[n-1]$ of characters from a finite alphabet $\Sigma$ of size $\sigma$. The substring $T[i..j]$ is the string $T[i] \cdots T[j]$, whereas the fragment $T[i..j]$ refers to the specific occurrence of $T[i..j]$ starting at position $i$ in $T$. If $i > j$, then $T[i..j]$ is the empty string. We additionally use the notation $T[i..j)$ and $T(i..j]$ which stand for $T[i..j-1]$ and $T[i+1..j]$ respectively. We call \emph{prefixes} the substrings of the form $T[0..i]$ and use the notation $T[..i]$, analogously \emph{suffixes} refer to substrings $T[j..n-1]$ and are denoted $T[j..]$.

\subsection{Tries and Suffix trees}

Let $\mathcal{S} = {S_1,S_2, ..., S_k}$ be a collection of strings over the alphabet $\Sigma$. Its trie~\cite{thue1912gegenseitige,de1959file,fredkin1960trie} is rooted tree with edge labels in $\Sigma$.
For any path from the root to the node we can consider the string \emph{spelled} from concatenating the label of the edges. The trie is such that no two nodes spell the same string, each leaf spells a string of $\mathcal{S}$ and each $T_i \in \mathcal{S}$ is spelled by a leaf or an internal node, in both cases we mark the node with a $\$ $.

The more efficient compacted trie is obtained by contracting  into a single edge any path from a node labeled by a \$ or branching (with at least two children) to its lowest ancestor that is either branching or labeled by a \$.
This edge is then labeled with the string spelled by the path it replaced.
Let $S$ be a string spelled by a node of the non-compacted trie, if it is also spelled by a node of the compacted trie we say it is \emph{explicit} else it is \emph{implicit}. Those definitions are illustrated in Figure~\ref{subfig:trie} and~\ref{subfig:compacttrie}. Note that for any two nodes $i$ and $j$, their lowest common ancestor spells the longest common prefix between the strings spelled by $i$ and $j$.
%
Although they are not needed in this manuscript it might be helpful for the reader to know that dynamic z-fast tries~\cite{belazzougui2010dynamic} have been designed specifically to optimize predecessor and successor (lexicographic order) queries and longest common prefix queries. Starikovskaya and Gawrychowsky then used z-fast tries to give a randomized implementation of the k-errata tree for streaming dictionary matching with mismatches~\cite{gawrychowski2019streaming}.

Patricia tries~\cite{morrison1968patricia} are compacted tries on the bit encoding of the strings, comparison are made bit by bit and therefore each node as at most two children. Radix tree also operate on the bit encoding of the strings but can compare several bits at a time. For a radix $r$, the radix tree compares the strings by blocks of $r$ bits and each node can have $2^r$ children, a patricia trie is a radix tree with $r=1$.

Notice that all nodes are either branching or a leaf and that all leaf spell a different string of $\mathcal{S}$, there are at most $\Oh(k)$ nodes in the compacted trie.
For each edge there exist $(i,s,e)$ such that its label is equal to $T_i[s .. e]$, thus we can avoid storing the label explicitly and just store the reference $(i,s,e)$.
Thus, $\Oh(k)$ words are sufficient to store the compacted trie.
%
With the addition of failure links to each node (which requires a preprocessing time in $\Oh(|T_1| + ... +|T_k|$)), the compacted trie can be used to detect the occurrence of all strings in $\mathcal{S}$ in a text $T$ in time $\Oh(|T|+occ)$ where $occ$ is the total number of occurrences. For a detailed explanation see Chapter 3.4 of~\cite{Gusfield1997}. 


A suffix trie of a string $T$ of length $n$ is the compacted trie containing exactly its suffixes ie over the collection $\{T[j..]\$$ for $ j \in [0,n-1] \}$. It can be stored in $O(n)$ space and for linearly-sortable alphabet constructed in $O(n)$ time~\cite{Farach1997}. For more details on the suffix tree see Chapter 5 to 9 of~\cite{Gusfield1997} and we illustrate this definition (with full strings instead of reference) in Figure~\ref{subfig:suffixtree}.

\todo[inline,color=teal]{Mention where they are used: Streaming Squares Gapped}

\input{Introduction/fig_tries_suffix.tex}

\subsection{Karp Rabin fingerprint}
\todo[inline,color=teal]{Mention where they are used: Streaming indirectly, LCS Approx XBWT}

\subsection{Periodicity and Fine-wilf lemma}
Compact run representation of occ crossing a given position

\subsection{Streaming pattern matching}
Application to the explanation of Breslauer \& Gallil (needed for both streaming)

\subsection{Heavy path decomposition}


\subsection{Compression techniques}
What type of compression is used on what problem and why ?
\begin{itemize}
\item RLE
\item Grammar
\item Lempel Ziv
\item BWT
\item State of the art on the equivalence through string attractors
\item Sketches
\end{itemize}