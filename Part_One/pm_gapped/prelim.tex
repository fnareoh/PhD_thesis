 
\section{Preliminaries}
\label{pmgapped:sec:prelim}
A \emph{string} $s$ of length $|s| = n$ is a sequence $s[0]s[1]\dots s[n-1]$ of characters from an integer alphabet~$\Sigma$ that can be sorted in $O(m+g)$ time.
A \emph{substring} of a string $s$ is a pair $(i,j)$ where  $0 \le i \le j < |s|$ and is identified with the string $s[i \dots j]=s[i] \dots s[j]$. We also use the notation $s[i \dots j)$ and $s(i \dots j]$ which stand for the substring $s[i \dots j-1]$ and $s[i-1 \dots j]$ respectively.
We say that a substring $s[i \dots j]$ is fully contained in another substring $s[i' \dots j']$ if $i' \le i \le j \le j'$. 
We call a substring $s[0 \dots i]$ \emph{a prefix} of $s$ and use a simplified notation $s[\dots i]$, and a substring $s[i \dots n-1]$ \emph{a suffix} of $s$ denoted by $s[i \dots]$. 
We say that $x$ occurs in $s$ at position $i$ if $x = s[i \dots i+|x|)$, alternatively we say $i$ is an occurence of $x$ in $s$.
Additionaly, an occurence $i$ is fully included in a substring $f$ of $s$ if $s[i \dots i+|x|)$ is fully included in $f$.
%

An occurrence $k_1$ of $p_1$ together with an occurrence $k_2$ of $p_2$ form a \emph{consecutive occurrence (co-occurrence)} $(k_1,k_2)$ of the strings $p_1,p_2$ in a string $s$ if there are no occurrences of $p_1$ in $(k_1,k_2]$ and no occurrences of $p_2$ in $[k_1,k_2)$. The distance $k_2-k_1$ is sometimes referred to as a \emph{gap}.

An integer $\pi$ is a \emph{period} of a string $s$ of length $n$ if $s[i]=s[i+\pi]$ for all $i=0,\dots, n-1-\pi$. We say that $s$ is \emph{periodic} if its smallest period, referred to as \emph{the period} of $s$, is at most $|s|/2$. We also exploit the well-known corollary of the Fine and Wilf's periodicity lemma~\cite{Fine1965}:


\begin{corollary}\label{pmgapped:cor:arithmetic_progression}
Let $x, y$ be strings such that $|x|\leq 2|y|$. If there are at least three occurrences of $y$ in $x$, then all occurrences of $y$ in $x$ form an arithmetic progression with difference equal to the period of $y$. 
\end{corollary}


\begin{proposition}
\label{prop:suffix_tree}
One can preprocess a string $p$ of length $m$ in $O(m)$ time and space to maintain the following queries in constant time: Given a substring $(i,j)$, find the leftmost and the rightmost occurrences of $p[i...j]$ in $p$, as well as the total number of occurrences. Given two substrings $(i,j)$ and $(k,l)$, compute the longest common prefix and longest common suffix between $p[i...j]$ and $p[k...l]$.
\end{proposition}
\begin{proof}
We assume the reader to be familiar with suffix trees. We build the suffix tree of $p$ in $O(m)$ time and space. Belazzougui et al.~\cite{belazzougui_et_al:LIPIcs.CPM.2021.8} showed that the suffix tree can be preprocessed in linear time so that, given a substring $(i,j)$, one can find the node $u$ of the suffix tree labeled by $p[i...j]$ in constant time. The leaves of the subtree of $u$ correspond to the occurrences of $p[i...j]$ in $p$.
%By maintaining the range minimum and the range maximum query data structures on the leaves of the suffix tree, that can be built in linear time and occupy linear space~\cite{10.1007/11780441_5}, one can find the leftmost and the rightmost occurrences of $x$ in $p$ in constant time.
For each node, we can precompute in linear time, the size of its subtree, the lefmost and rightmost occurrences of its label. This is done by simply traversing the tree from the bottom to the top and propagating the information.
%By storing the size of the subtrees of each node of the suffix tree, which can be precomputed in linear time and space as well, one can also output the total number of occurrences of $p[i..j]$ in $p$ in constant time.
We also preprocess the suffix trees in linear time so that they can fing the lowest common ancestor between two nodes in constant time~\cite{bender2000lca}. Given two substrings $(i,j)$ and $(k,l)$ the length of the label of their common ancestor is their longest common prefix. Analogously, by having the same suffix tree built for the reversed string, we can compute the longest common suffix.
\end{proof}

\begin{corollary}[{of Corollary~\ref{pmgapped:cor:arithmetic_progression} and Proposition~\ref{prop:suffix_tree}}]
\label{cor:imp}
One can preprocess a string $p$ of length $m$ in $O(m)$ time and space to maintain the following queries in constant time: Given a substring $(i,j)$, such that $j-i\ge m/2$, one can output the arithmetic progression of the occurrences of $p[i...j]$ in $p$ in constant time.
\end{corollary}



\subsection{Grammars}
\begin{definition}[Straight-line program~\cite{tit/KiefferY00}]
A \emph{straight-line program} (SLP)  is a context-free grammar (CFG) consisting of a set of non-terminals $X_1, \ldots, X_q$, a set of terminals, an initial symbol $X_q$, and a set of productions, satisfying the following properties:
\begin{itemize}
\item A production consists of a left-hand side and a right-hand side, where the left-hand side is a non-terminal $X_i$ and the right-hand side is a sequence $X_jX_k$, where $j,k < i$, or a terminal;
\item Every non-terminal is on the left-hand side of exactly one production.
\end{itemize}
\end{definition}


The \emph{expansion} $\str{S}$ of a sequence of terminals and non-terminals $S$ is the string that is obtained by iteratively replacing non-terminals by the right-hand sides in the respective productions, until only terminals remain. We say that $G$ \emph{represents} the expansion $\str{G}$ of its initial symbol.

\begin{definition}[Parse tree]
 The \emph{parse tree} of a SLP is defined as follows: 
\begin{itemize}
\item The root is labeled by the initial symbol;
\item Each internal node is labeled by a non-terminal;
\item If $S$ is the expansion of the initial symbol, then the $i^{\text{th}}$ leaf of the parse tree is labeled by a terminal $S[i]$;
\item A node labeled with a non-terminal $A$ that is associated with a production $A\rightarrow BC$ has two children labeled by $B$ and $C$, respectively.
\end{itemize}
\end{definition}

The \emph{size} of a grammar is the total size of all right-hand sides of all productions. The \emph{height} of a grammar is the height of the parse tree.  

%\begin{definition}[Primary occurrence]
%Let $A$ be a non-terminal of $G$ associated with a production $A \rightarrow BC$. We say that a occurrence $i$ of $p$ in $\str{A}$ is \emph{primary} if $i \le |\str{B}| \le i + |p|-1$.   
%\end{definition}