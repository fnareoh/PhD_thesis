\newcommand{\inputindexgapped}[1]{\input{Part_One/index_gapped/#1}}
\newcommand{\psubref}[1]{(\subref{#1})}

\newcommand{\ov}{\mathrm{ov}}
\newcommand{\str}[1]{\overline{#1}}
\newcommand{\Tpre}{$T_{pre}$}
\newcommand{\Tsuf}{$T_{suf}$}
\newcommand{\lsplits}{\mathrm{Splits}}
\newcommand{\rsplits}{\mathrm{Splits}_\mathrm{rev}}
\newcommand{\splits}{\mathrm{Splits}'}
\newcommand{\pre}[1]{\mathrm{pre}(#1)}
\newcommand{\suf}[1]{\mathrm{suf}(#1)}
% Secondary occurrences
\newcommand{\anc}{\mathrm{anc}}
\newcommand{\off}{\mathrm{off}}
\newcommand{\nextnode}{\mathrm{next}}

\newcommand{\parent}{\textsf{parent}}
\newcommand{\rext}{\textsf{rext}}
\newcommand{\lext}{\textsf{lext}}
\newcommand{\sig}{\textsf{sig}}
\newcommand{\lft}{\textsf{left}}
\newcommand{\rght}{\textsf{right}}
\newcommand{\depth}{\textsf{depth}}
\newcommand{\ind}{\textsf{index}}
\newcommand{\rhs}{\textsf{rhs}}
\newcommand{\lab}{\lambda}
\newcommand{\head}{\textsf{head}}
\newcommand{\tail}{\textsf{tail}}
\newcommand{\Pset}{\mathcal{P}}
\renewcommand{\occ}[0]{\mathrm{output}}


\contextbox{Publication}{
This chapter corresponds to the following publication:~\fullcite{DBLP:conf/cpm/GawrychowskiGSS23}.
}

\begin{small}
The fundamental question considered in algorithms on strings is that of indexing, that is, preprocessing
a given string for specific queries. By now we have a number of efficient solutions for this problem when
the queries ask for an exact occurrence of a given pattern~$P$. However, practical applications motivate
the necessity of considering more complex queries, for example concerning near occurrences of two patterns. Recently, Bille et al. [CPM 2021] introduced a variant of such queries, called gapped consecutive occurrences,
in which a query consists of two patterns $P_{1}$ and $P_{2}$ and a range $[a,b]$, and one must find all consecutive occurrences $(q_1,q_2)$ of $P_{1}$
and $P_{2}$ such that $q_2-q_1 \in [a,b]$. By their results, we cannot hope for a very efficient indexing structure
for such queries, even if $a=0$ is fixed (although at the same time they provided a non-trivial upper bound). Motivated by
this, we focus on a text given as a straight-line program (SLP) and design an index taking space polynomial in the size of the grammar that answers such queries in time optimal up to polylog factors.
\end{small}

\inputindexgapped{intro}
\inputindexgapped{prelim}
\inputindexgapped{occurrences}
\inputindexgapped{close}
