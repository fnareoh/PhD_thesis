\mainmatter
\newcommand{\rot}{\mathsf{rot}}
\newcommand{\dd}{\mathinner{.\,.\allowbreak}}
\newcommand{\Ohtilda}{\tilde{O}}
\newcommand{\eps}{\varepsilon}
\newcommand{\occ}{\mathsf{occ}}
\newcommand{\Diff}{\mathsf{Diff}}
\newcommand{\Overlap}{\mathsf{Overlap}}
\newcommand{\Zp}{Z_+}

\contextbox{Chapter based on publication}{
This chapter corresponds to the following publication: \fullcite{streaming_regexp}\\
My personal contribution to this work has been the formalization of anchors and proofs of their key properties. I also participated in the overall algorithms design.
TODO: Detail (also in the intro) how it connects to the rest of the thesis and which preliminaries are helpful.
}
\begin{small}
Regular expression search is a key primitive in myriads of applications, from web scrapping to bioinformatics.
A regular expression is a formalism for compactly describing a set of strings, built recursively from single characters
using three operators: concatenation, union, and Kleene star. Two basic algorithmic problems concerning
such expressions are membership and pattern matching.
In the regular expression membership problem, we are given a regular expression $R$ and a string~$T$ of length $n$, and must decide whether $T$ matches~$R$. In the regular expression pattern matching problem, the task to find the substrings of $T$ that match $R$. 

By now we have a good understanding of the complexity of regular expression membership and pattern matching
in the classical setting. However, only some special cases have been considered in the practically relevant streaming
setting:
dictionary matching and wildcard pattern matching. In the dictionary matching problem, we are given a dictionary of $d$ strings of
length at most $m$ and a string $T$, and must find substrings of~$T$ that match one of the dictionary strings. In the wildcard pattern
matching problem, we are given a string $P$ of length $m$ that contains $d$ wildcards, where a wildcard is a special symbol that matches
any character of the alphabet, and a string $T$, and must find all substrings of $T$ that match $P$. Both problems can be solved in the
streaming model by a randomised Monte Carlo algorithm that uses $\Oh(d \log m)$ space [Golan and Porat (ESA 2017), Golan, Kopelowitz
and Porat (Algorithmica 2019)]. 

In the general case, we cannot hope for a streaming algorithm with space complexity smaller than the length of $R$ for either variant
of regular expression search.
The main contribution of this paper is that we identify the number of unions and Kleene stars, denoted by $d$, as the parameter
that allows for an efficient streaming algorithm. This parameter has been previously considered in the classical setting, and
it has been observed that in practice it is significantly smaller than the length of $R$.
We design general randomised Monte Carlo algorithms for both problems that use $\Oh(d^3 \polylog n)$ space
in the streaming setting.

A crucial technical ingredient of our algorithms is an adaptation of the general framework for evaluating a circuit with addition and convolution gates in a space-efficient manner [Lokshtanov and Nederlof (STOC 2010), Bringmann (SODA 2017)], initially designed as a key component of a pseudopolynomial time algorithm for the subset sum problem. We show how to replace the Extended Generalised Riemann Hypothesis in [Bringmann (SODA 2017)] by an application of the Bombieri--Vinogradov theorem to achieve the same bounds (but unconditionally), which might be of independentinterest.
\end{small}

\section{Introduction}
\label{regexp:sec:introduction}
\input{Part_One/streaming_regex_pattern_matching/introduction}

\section{Preliminaries}
\label{regexp:sec:prelim}
\input{Part_One/streaming_regex_pattern_matching/preliminaries}

\section{Technical Overview}
\label{regexp:sec:overview}
\input{Part_One/streaming_regex_pattern_matching/overview}

\section{Regular Expression Membership and Pattern Matching}\label{sec:regexp}
In this section, we address the problems of regular expression membership and pattern matching in the streaming model of computation. In Section~\ref{regexp:sec:anchors}, we introduce a notion of \emph{anchors} that is the key to achieving the desired space complexity. In Section~\ref{regexp:sec:algorithms}, we describe the algorithms.

\subsection{Anchors}
\label{regexp:sec:anchors}
\input{Part_One/streaming_regex_pattern_matching/anchors}

\subsection{Algorithms}
\label{regexp:sec:algorithms}
\input{Part_One/streaming_regex_pattern_matching/algorithms}

\section{Proof of Theorem~\ref{thm:detecting_walk_specific_weight}}
\label{regexp:sec:paths-in-graph}
\input{Part_One/streaming_regex_pattern_matching/paths-in-graph}

\BiblatexSplitbibDefernumbersWarningOff

\backmatter
\todo[inline]{Fix links to some DOI not working}
\printbibliography[heading=subbibintoc]