\newcommand{\inputsquare}[1]{\input{Part_One/unordered_repetitions/#1}}

\newcommand{\D}{{\bf D}}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\Tphrase}{\mathcal{T}_{\mathrm{phrase}}}
\newcommand{\Sparse}{\mathcal{S}_{\mathrm{parse}}}
\newcommand{\Tparse}{T_{\mathrm{parse}}}
\newcommand{\lce}{\textnormal{\textsc{lce}}}

\newcommand{\quotes}[1]{``#1''}
\newcommand{\absolute}[1]{\left\lvert#1\right\rvert}
\newcommand{\tuple}[1]{\left\langle#1\right\rangle}

\contextbox{Publication}{
This chapter corresponds to the extended version of the following publication: \fullcite{DBLP:conf/soda/EllertGG23}. The results specific to this extended version are the reporting of all runs in optimal time.
}
\begin{small}
Squares (fragments of the form $xx$, for some string $x$) are arguably the most natural type of repetition in strings.
The basic algorithmic question concerning squares is to check if a given string of length $n$ is square-free, that is, does not contain
a fragment of such form. Main and Lorentz [J. Algorithms 1984] designed an $\mathcal{O}(n\log n)$ time algorithm
for this problem, and proved a matching lower bound assuming the so-called general alphabet, meaning that the algorithm
is only allowed to check if two characters are equal. 
However, their lower bound also assumes that there are $\Omega(n)$ distinct symbols in the string.
As an open question, they asked if there is a faster algorithm if one restricts
the size of the alphabet. Crochemore [Theor. Comput. Sci. 1986] designed a linear-time algorithm for constant-size alphabets,
and combined with more recent results his approach in fact implies such an algorithm for linearly-sortable alphabets.
Very recently, Ellert and Fischer [ICALP 2021] significantly relaxed this assumption by designing a linear-time algorithm for
general ordered alphabets, that is, assuming a linear order on the characters that permits constant time order comparisons. However, the open question of Main and Lorentz
from 1984 remained unresolved for general (unordered) alphabets.  In this paper, we show that testing square-freeness of a length-$n$ string over
general alphabet of size $\sigma$ can be done with $\mathcal{O}(n\log \sigma)$ comparisons, and cannot be done with $o(n\log \sigma)$ comparisons.
We complement this result with an $\mathcal{O}(n\log \sigma)$ time algorithm in the Word RAM model.
Finally, we extend the algorithm to reporting all the runs (maximal repetitions) in the same complexity.
\end{small}

\inputsquare{intro}
\inputsquare{prelim}
\inputsquare{inapprox}
\inputsquare{lowerbound}
\inputsquare{upperbound}
\inputsquare{algorithm}
\inputsquare{no_log_star}
\inputsquare{runs}

