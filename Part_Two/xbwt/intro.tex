\section{Introduction}
\label{xbwt:sec:introduction}

The FM-index~\cite{ferragina2005indexing} is an important data structure in both combinatorial pattern matching and bioinformatics.  Its most important application so far has been in standard short-read aligners --- Bowtie~\cite{langmead2009ultrafast,langmead2012fast} and BWA~\cite{li2009fast} have together over 70 thousand citations and are used every day in clinics and research labs worldwide --- but it has myriad other uses and more are still being discovered.  Just within computational genomics, FM-indexes have been generalized from single strings to collections of strings for tools such as BEETL~\cite{Beetl}, RopeBWT~\cite{ropebwt2} and Spring~\cite{spring}, to de Bruijn graphs for tools such as BOSS~\cite{BOSS}, VARI~\cite{muggli2017succinct} and Rainbowfish~\cite{almodaresi2017rainbowfish}, and to graphs for tools such as vg~\cite{garrison2018variation}. Recent breakthroughs~\cite{gagie2020fully} mean we can now scale FM-indexes to massive but highly repetitive pan-genomic datasets for a new generation of tools~\cite{kuhnle2020efficient}.

As genomic datasets grow exponentially (from the Human Genome Project to the 1000 Genomes Project and the 100K Genomes Project) and standards for sequencing coverage increase (from less than 10x a few years ago to 30x and 50x now and over 100x for some applications), an obvious question is whether and how the recent breakthroughs in FM-indexing of repetitive datasets can be turned into comparable advances in indexing readsets, so more researchers can efficiently mine them for biomedical insights. For example, extrapolating from previous experiments~\cite{kuhnle2020efficient}, it should be possible to index both haplotypes from  2705 individuals in less than 100 GB of RAM.  In contrast, the readset from the final phase of the 1000 Genomes Project consisted of reads from 2705 individuals and was released as a 464 GB Burrows-Wheeler Transform (BWT)~\cite{dolle2017using}, which is beyond the resources of most labs to process.
This almost five-fold increase (from 100 to 464 GB) seems reasonable, given the range of lengths and the error rate of short-read sequencing technologies, but those reads were trimmed and error-corrected before their BWT was computed, making that increase harder to justify and thus a target for improvement.  Although experimenting with that particular readset is beyond the scope of this paper, since it occupies 87 TB uncompressed, we expect the insights and techniques we develop here will eventually be useful in software able to handle efficiently inputs of that scale.

{Recent results on FM-indexing repetitive datasets~\cite{gagie2020fully} have shown that the index performance depends on the number of runs in the transformed sequence, where a run is a maximal non-empty unary substring. For example, if the BWT of a dataset of (uncompressed) size $n$ has $r$ runs, we can design an FM-index of size $O(r \log\log n)$ supporting the count and locate operations in optimal linear time. Hence, if a BWT variant produces a transformed string with a smaller number of runs, the resulting index will be smaller and equally fast.} The na\"ive approach to FM-indexing readsets is to concatenate the reads with copies of a separator character between them, and FM-index the resulting single string.  However, computing the BWT of such a long string is a challenge and each separator character causes several runs in that BWT.  The most competitive indexes for readsets are based on Mantaci et al.'s~\cite{MANTACI2007298} Extended Burrows Wheeler Transform, which is also easier to build for readsets.  
The first index for readsets based on the EBWT was BEETL~\cite{Beetl}, followed by RopeBWT~\cite{ropebwt2}; recently the EBWT has been used also by the Spring compressor~\cite{spring} specialized for FASTQ reads. BEETL and RopeBWT use explicit separator characters but such characters could be replaced by bitvectors marking positions at the ends of reads. %the experiments in this paper indicate that the use of bitvectors is indeed worthwhile. 


BEETL and RopeBWT use a heuristic to reduce the number of runs in the EBWT: they conceptually put the separator characters at the ends of reads into the co-lexicographic order (lexicographic order on the reverse string, also referred to as reverse lexicographic order) of the reads, so that the final characters or reads with similar suffixes are grouped together in the EBWT.  This often works surprisingly well but in the worst case it cannot make up for the lack of context for sorting those characters into their places in the EBWT.  Our proposal in this paper is to graft the reads onto their assembled genome, or a reference genome to which they align well, and index the resulting labelled tree with Ferragina et al.'s~\cite{ferragina2009compressing} XBWT.
To this end we assume that we know how the reads align to the assembled/reference genome: this is not an unreasonable assumption since alignment is the initial step of any readset analysis.

In order to implement our idea we have to overcome a significant hurdle: as the coverage increases so does the amount of raw data produced by a single NGS experiment. Although the high coverage implies that the data is highly compressible, the actual compression process, ie the construction and the compression of the XBWT, must be done partially in externally memory since the input will be usually much larger than the available RAM. Another contribution of the paper is therefore the adaptation of the prefix-free parsing (PFP) technique~\cite{boucher2019prefix} to the construction of the XBWT. PFP has been proposed for the construction of BWTs of collections of similar genomes: the initial parsing phase is able to compress the input maintaining enough information to compute the BWT working on the compressed representation. In this paper we adapt PFP to readsets, taking care also of the ``grafting'' of the single reads to the reference/assembled genome.
Given a pattern $P$, our index could answer $count(P)$ and $locate(P)$ queries which report respectively the number of positions where $P$ occurs and the list of positions where $P$ occurs. The main drawback to our index, apart from taking one or more assembled or partially assembled genomes as a base, is that it can return a false-positive in the $count$ operation when an occurrence of a pattern starts in the trunk of an alignment tree and ends in a branch.  In other words, the index can report a match that is not completely contained within a read but would be if we padded the read on the left with enough characters copied from just before where it aligns. In a locate operation false-positives could be identified, but this operation is much slower. Even this is not entirely bad, however, and it is conceivable this bug could sometimes be a feature.
The analysis of those false positive and the size of the bit vectors marking the end of reads is left as future work.

The rest of the paper is organized as follows. In Section~\ref{xbwt:sec:concepts} we first describe the BWT and FM-indexes, then the EBWT and XBWT and the concept of Wheeler graph that unifies them. 
In Section~\ref{xbwt:sec:main} we introduce our idea for indexing aligned readsets with the XBWT {and we prove some theoretical results supporting it}.  In Section~\ref{xbwt:sec:pfp} we describe how we adapt PFP to indexing readsets, which allows us to experiment with larger files than would otherwise be possible with reasonable resources. In Section~\ref{xbwt:sec:practice} we present our experimental results showing that applying the XBWT to index readsets works well in practice as well as in theory. Finally, we outline in Section~\ref{xbwt:sec:JST} how our study of storing reads with the XBWT may improve the space usage of the hybrid index~\cite{ferrada2014hybrid,ferrada2018hybrid,gagie2015searching}.